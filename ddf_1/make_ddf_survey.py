import numpy as np
import gurobipy as gp
from gurobipy import GRB
import scipy.sparse as sp
from scipy.stats import binned_statistic
import matplotlib.pylab as plt
from rubin_sim.utils import calcSeason
from rubin_sim.utils import ddf_locations


def optimize_ddf_times(ddf_name, ddf_RA, ddf_grid,
                       sun_limit=-18, airmass_limit=2.1, sky_limit=22,
                       sequence_limit=400, season_frac=0.2,
                       time_limit=200):
    """Run gyrobi to optimize the times of a ddf

    Parameters
    ----------
    ddf : `str`
        The name of the DDF
    ddf_grid : `np.array`
        An array with info for the DDFs. Generated by the `generate_grid.py` script

    season_frac : `float`
        7.2 month observing season if season_frac = 0.2
    """

    sun_limit = np.radians(sun_limit)

    # XXX-- double check that I got this right
    ack = ddf_grid['sun_alt'][0:-1] * ddf_grid['sun_alt'][1:]
    night = np.zeros(ddf_grid.size, dtype=int)
    night[np.where((ddf_grid['sun_alt'][1:] >= 0) & (ack < 0))] += 1
    night = np.cumsum(night)

    m = gp.Model(ddf_name)

    ngrid = ddf_grid['mjd'].size

    # Let's try scheduling just one for now
    schedule = m.addMVar(ngrid, vtype=GRB.BINARY, name="pointing_1")

    # set a sun mask
    sun_mask = np.zeros(ngrid, dtype=bool)
    sun_mask[np.where(ddf_grid['sun_alt'] >= sun_limit)] = 1

    airmass_mask = np.zeros(ngrid, dtype=bool)
    airmass_mask[np.where(ddf_grid['ELAISS1_airmass'] >= airmass_limit)] = 1

    sky_mask = np.zeros(ngrid, dtype=bool)
    sky_mask[np.where(ddf_grid['ELAISS1_sky_g'] <= sky_limit)] = 1
    sky_mask[np.where(np.isnan(ddf_grid['ELAISS1_sky_g']) == True)] = 1

    # Let's add the constraints
    m.addConstr(schedule @ sun_mask == 0)
    m.addConstr(schedule @ airmass_mask == 0)
    m.addConstr(schedule @ sky_mask == 0)

    # limit the total number of ddf sequences
    # Need to set an exact number I think. Or maybe a range.
    m.addConstr(schedule.sum() == sequence_limit)

    # prevent a repeat sequence in a night
    unights, indx = np.unique(night, return_index=True)
    night_mjd = ddf_grid['mjd'][indx]
    # The season of each night
    night_season = calcSeason(ddf_RA, night_mjd)
    sched_night = m.addMVar(unights.size, vtype=GRB.INTEGER)
    for i, n in enumerate(unights):
        in_night = np.where(night == n)[0]
        m.addConstr(schedule[in_night]@schedule[in_night] <= 1)
        m.addConstr(sched_night[i] == schedule[in_night].sum())

    raw_obs = np.ones(unights.size)
    # take out the ones that are out of season
    season_mod = night_season % 1
    out_season = np.where((season_mod < season_frac) | (season_mod > (1.-season_frac)))
    raw_obs[out_season] = 0
    cumulative_desired = np.cumsum(raw_obs)
    cumulative_desired = cumulative_desired/cumulative_desired.max()*sequence_limit

    # Makes it go blazing fast agian, that's for sure!
    cumulative_desired = np.round(cumulative_desired)

    # Cumulative number of scheduled events (by night, to avoid huge loop)
    cumulative_sched = m.addMVar(unights.size, vtype=GRB.INTEGER)
    cumulative_diff = m.addMVar(unights.size, vtype=GRB.INTEGER, lb=-sequence_limit, ub=sequence_limit)

    m.addConstr(cumulative_sched[0] == sched_night[0])

    m.addConstr(cumulative_diff[0] == cumulative_sched[0] - cumulative_desired[0])

    for i in np.arange(1, unights.size):
        m.addConstr(cumulative_sched[i] == cumulative_sched[i-1]+sched_night[i])
        m.addConstr(cumulative_diff[i] == cumulative_sched[i] - cumulative_desired[i])

    # Try to match a CDF
    # I think this is basically a chi^2 minimization. If we did absolute val difference, it would be linear and
    # then it's easier to do more than one simultaneously.
    m.setObjective(cumulative_diff@cumulative_diff, GRB.MINIMIZE)
    m.Params.TimeLimit = time_limit
    m.optimize()
    result_array = schedule.X

    nights_to_use = night[np.where(result_array == 1)]

    # For each night, find the best time in the night. 
    mjds = []
    for night_check in nights_to_use:
        in_night = np.where((night == night_check) & (np.isfinite(ddf_grid['%s_m5_g' % ddf_name])))[0]
        m5s = ddf_grid['%s_m5_g' % ddf_name][in_night]
        # we could intorpolate this to get even better than 15 min resolution on when to observe
        max_indx = np.where(m5s == m5s.max())[0].min()
        mjds.append(ddf_grid['mjd'][in_night[max_indx]])

    return mjds


if __name__ == "__main__":
    ddfs = ddf_locations()
    ddf_data = np.load('ddf_grid.npz')
    ddf_grid = ddf_data['ddf_grid'].copy()

    ddf_name = 'ECDFS'

    mjds = optimize_ddf_times(ddf_name, ddfs[ddf_name][0], ddf_grid, time_limit=30)
    import pdb ; pdb.set_trace()
